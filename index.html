<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Character Border Processor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #6b46c1 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="50" cy="50" r="1" fill="rgba(255,255,255,0.02)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            padding: 35px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #667eea, #764ba2, #e83e8c, #667eea);
            border-radius: 27px;
            z-index: -1;
            opacity: 0.3;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #333;
            font-size: 3.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2, #e83e8c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .header p {
            color: #666;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .header .subtitle {
            color: #888;
            font-size: 1em;
            font-style: italic;
            margin-bottom: 20px;
        }

        .camelot-badge {
            display: inline-block;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin: 10px 5px;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .taskalot-badge {
            display: inline-block;
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin: 10px 5px;
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
        }

        .footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            padding: 20px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            color: #666;
            font-size: 0.9em;
        }

        .footer-left, .footer-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .footer-left {
            color: #333;
            font-weight: 500;
        }

        .footer-right {
            color: #666;
            font-weight: 500;
        }

        .footer-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 8px;
            vertical-align: middle;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .input-section, .output-section {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
        }

        .section-title {
            color: #333;
            font-size: 1.5em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 50%;
            display: inline-block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
        }

        input, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
        }

        input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 200px;
            font-family: monospace;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #2ed573, #1e90ff);
        }

        .btn-secondary:hover {
            box-shadow: 0 7px 20px rgba(46, 213, 115, 0.4);
        }

        .processing-status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            display: none;
        }

        .status-processing {
            background: rgba(255, 193, 7, 0.1);
            border-left: 4px solid #ffc107;
            color: #856404;
        }

        .status-success {
            background: rgba(40, 167, 69, 0.1);
            border-left: 4px solid #28a745;
            color: #155724;
        }

        .status-error {
            background: rgba(220, 53, 69, 0.1);
            border-left: 4px solid #dc3545;
            color: #721c24;
        }

        .output-code {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            min-height: 200px;
        }

        .copy-btn {
            background: #2ed573;
            margin-top: 10px;
        }

        .copy-btn:hover {
            background: #26d46a;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .container {
                padding: 20px;
            }
        }

        .rarity-badges {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .rarity-badge {
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 13px;
            font-weight: bold;
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .rarity-badge::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .rarity-badge:hover::before {
            left: 100%;
        }

        .rarity-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .rarity-D { 
            background: linear-gradient(45deg, #6c757d, #495057);
            border: 2px solid #495057;
        }
        .rarity-C { 
            background: linear-gradient(45deg, #28a745, #20c997);
            border: 2px solid #20c997;
        }
        .rarity-B { 
            background: linear-gradient(45deg, #007bff, #6610f2);
            border: 2px solid #6610f2;
        }
        .rarity-A { 
            background: linear-gradient(45deg, #ffc107, #fd7e14);
            border: 2px solid #fd7e14;
        }
        .rarity-S { 
            background: linear-gradient(45deg, #dc3545, #e83e8c);
            border: 2px solid #e83e8c;
        }
        .rarity-SS { 
            background: linear-gradient(45deg, #6f42c1, #e83e8c);
            border: 2px solid #e83e8c;
        }

        .manual-input-section {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
            margin-bottom: 30px;
        }

        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .input-grid .form-group:nth-child(3),
        .input-grid .form-group:nth-child(4) {
            grid-column: span 1;
        }

        .input-grid .form-group:nth-child(5),
        .input-grid .form-group:nth-child(6) {
            grid-column: span 1;
        }

        .input-grid .form-group:nth-child(7) {
            grid-column: span 2;
        }

        .rarity-select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
        }

        .rarity-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .manual-characters-list {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .character-item {
            background: white;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .character-info {
            flex: 1;
        }

        .character-name {
            font-weight: bold;
            color: #333;
        }

        .character-details {
            font-size: 0.9em;
            color: #666;
        }

        .remove-char-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-char-btn:hover {
            background: #c82333;
        }

        .tab-container {
            margin-bottom: 30px;
        }

        .tab-buttons {
            display: flex;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .tab-button {
            flex: 1;
            padding: 15px 25px;
            border: none;
            background: transparent;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .tab-button.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .tab-button:hover:not(.active) {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .settings-button {
            position: absolute;
            top: 15px;
            right: 25px;
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            z-index: 100;
        }

        .settings-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #333;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .api-key-field {
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .api-key-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
            font-family: monospace;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .api-key-toggle {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .api-key-toggle:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        .api-key-status {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .api-key-status.valid {
            color: #28a745;
        }

        .api-key-status.invalid {
            color: #dc3545;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .upload-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 8px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .upload-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .upload-btn input[type="file"] {
            display: none;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .api-testing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 20000;
        }

        .api-testing-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .api-testing-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .api-testing-text {
            color: #333;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .api-testing-subtext {
            color: #666;
            font-size: 14px;
        }

        .loading-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #333;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .loading-subtext {
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎌 Anime Character Border Processor</h1>
            <p>Transform your anime/manga characters with beautiful rarity borders and upload to ImgBB</p>

            <div class="rarity-badges">
                <span class="rarity-badge rarity-D">D Rank</span>
                <span class="rarity-badge rarity-C">C Rank</span>
                <span class="rarity-badge rarity-B">B Rank</span>
                <span class="rarity-badge rarity-A">A Rank</span>
                <span class="rarity-badge rarity-S">S Rank</span>
                <span class="rarity-badge rarity-SS">SS Rank</span>
            </div>
        </div>

        <button class="settings-button" onclick="openApiKeyModal()">
            ⚙️ API Settings
        </button>

        <!-- Hidden API Key Field -->
        <input type="hidden" id="apiKey" value="">

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('manual')">
                    <span>👤</span>
                    Adding Manually
                </button>
                <button class="tab-button" onclick="switchTab('code')">
                    <span>📝</span>
                    Inputting Code
                </button>
            </div>

            <!-- Manual Input Tab -->
            <div id="manual-tab" class="tab-content active">
                <div class="manual-input-section">
                    <h3 class="section-title">
                        <span class="icon"></span>
                        Add Characters Manually
                    </h3>

                    <div class="input-grid">
                        <div class="form-group">
                            <label for="animeInfoNum">Anime Info Number:</label>
                            <input type="number" id="animeInfoNum" placeholder="e.g., 1, 2, 3..." min="0">
                        </div>

                        <div class="form-group">
                            <label for="charId">Character ID:</label>
                            <input type="number" id="charId" placeholder="Character ID" min="0">
                        </div>

                        <div class="form-group">
                            <label for="charName">Name:</label>
                            <input type="text" id="charName" placeholder="Character name">
                        </div>

                        <div class="form-group">
                            <label for="charAlias">Aliases (optional):</label>
                            <input type="text" id="charAlias" placeholder="Alias1, Alias2, Alias3">
                        </div>

                        <div class="form-group">
                            <label for="charGender">Gender:</label>
                            <select id="charGender" class="rarity-select">
                                <option value="">Select gender</option>
                                <option value="M">Male</option>
                                <option value="F">Female</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="charRarity">Rarity:</label>
                            <select id="charRarity" class="rarity-select">
                                <option value="">Select rarity</option>
                                <option value="D">D Rank</option>
                                <option value="C">C Rank</option>
                                <option value="B">B Rank</option>
                                <option value="A">A Rank</option>
                                <option value="S">S Rank</option>
                                <option value="SS">SS Rank</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="charImage">Uploaded Image URL (ImgBB/ Imgur):</label>
                            <input type="text" id="charImage" placeholder="Image URL">
                            <button class="upload-btn" onclick="document.getElementById('imageFileUpload').click()">
                                📁 Upload Image File
                                <input type="file" id="imageFileUpload" accept="image/*" onchange="handleImageUpload(event)">
                            </button>
                        </div>
                    </div>

                    <button class="btn btn-secondary" onclick="addManualCharacter()">➕ Add Character</button>
                    <button class="btn" onclick="clearAllManualCharacters()" style="margin-left: 10px; background: linear-gradient(45deg, #dc3545, #c82333);">🗑️ Clear All</button>
                    <button class="btn copy-btn" onclick="copyManualCharacters()" style="margin-left: 10px;">📋 Copy Manual Characters</button>

                    <div class="manual-characters-list" id="manualCharactersList">
                        <!-- Manually added characters will appear here -->
                    </div>
                </div>
            </div>

            <!-- Code Input Tab -->
            <div id="code-tab" class="tab-content">
                <div class="main-content">
                    <div class="input-section">
                        <h3 class="section-title">
                            <span class="icon"></span>
                            Paste Character Code
                        </h3>



                        <div class="form-group">
                            <label for="charCode">Character Code:</label>
                            <textarea id="charCode" placeholder="Paste your character code here, e.g.:

new charInfo('Naruto Uzumaki', ['Naruto'], anime[0], 'M', 'https://i.imgur.com/example.png', 1, 'S')
new charInfo('Sakura Haruno', ['Sakura'], anime[1], 'F', 'xyz123', 2, 'A')

You can paste multiple characters at once..."></textarea>
                        </div>

                        <button class="btn btn-secondary" onclick="processCharacters()">🎨 Apply Borders & Upload</button>

                        <div class="processing-status" id="statusDiv">
                            <div id="statusText"></div>
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill"></div>
                            </div>
                        </div>
                    </div>

                    <div class="output-section">
                        <h3 class="section-title">
                            <span class="icon"></span>
                            Generated Code
                        </h3>

                        <div class="output-code" id="outputCode">// Your processed character code will appear here...
// Paste your existing character code and click "Apply Borders & Upload"

Expected input format:
new charInfo('Name', ['Alias'], anime[0], 'M', 'image_url', 1, 'S'),

Output format (with processed images):
new charInfo('Name', ['Alias'], anime[0], 'M', 'processed_image_url', 1, 'S'),</div>

                        <button class="btn copy-btn" onclick="copyOutput()">📋 Copy Code</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <div class="footer-left">
                <img src="https://i.ibb.co/Mkd8zL84/Ta2YDBN.png" class="footer-icon" alt="Camelot">
                Camelot • Made by Apollo24
            </div>
            <div class="footer-right">
                225px Vault Task Group • Taskalot
                <img src="https://i.ibb.co/VYyHWqbn/image.png" class="footer-icon" alt="Taskalot">
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loadingText">Uploading Image...</div>
            <div class="loading-subtext" id="loadingSubtext">Please wait while we upload your image to ImgBB</div>
        </div>
    </div>

    <!-- API Testing Overlay -->
    <div class="api-testing-overlay" id="apiTestingOverlay">
        <div class="api-testing-content">
            <div class="api-testing-spinner"></div>
            <div class="api-testing-text" id="apiTestingText">Testing API Key...</div>
            <div class="api-testing-subtext" id="apiTestingSubtext">Please wait while we validate your ImgBB API key</div>
        </div>
    </div>

    <!-- API Key Settings Modal -->
    <div class="modal-overlay" id="apiKeyModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">🔑 ImgBB API Key Settings</h3>
                <button class="modal-close" onclick="closeApiKeyModal()">&times;</button>
            </div>
            
            <p style="margin-bottom: 20px; color: #666;">
                Enter your ImgBB API key to enable image uploads. You can get a free API key from 
                <a href="https://api.imgbb.com/" target="_blank" style="color: #667eea;">api.imgbb.com</a>
            </p>
            
            <div class="api-key-field">
                <input type="password" id="modalApiKey" class="api-key-input" placeholder="Enter your ImgBB API key" value="">
                <button type="button" class="api-key-toggle" onclick="toggleModalApiKeyVisibility()">👁️ Show</button>
            </div>
            <div class="api-key-status" id="modalApiKeyStatus">API Key is hidden</div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeApiKeyModal()">Cancel</button>
                <button class="btn" onclick="saveApiKey()">💾 Save API Key</button>
            </div>
        </div>
    </div>

    <script>
        // Updated borders with ImgBB alternatives (replace your borders object)
        const borders = {
            // Original imgur URLs as primary
            "D": "https://i.imgur.com/fzfqbff.png",
            "C": "https://i.imgur.com/TUHq2Xq.png",
            "B": "https://i.imgur.com/I5vCYXc.png",
            "A": "https://i.imgur.com/6QIf4wm.png",
            "S": "https://i.imgur.com/g7Z8tXL.png",
            "SS": "https://i.imgur.com/2fXUIrn.png"
        };

        // Fallback borders hosted on ImgBB (you'll need to upload these)
        const borderFallbacks = {
            "D": "https://i.ibb.co/gbQxcp6n/fzfqbff.png",
            "C": "https://i.ibb.co/LzjKZYtY/TUHq2Xq.png",
            "B": "https://i.ibb.co/nss3mXxc/I5vCYXc.png",
            "A": "https://i.ibb.co/NdFKrJ0Z/6QIf4wm.png",
            "S": "https://i.ibb.co/fzV5BMTB/g7Z8tXL.png",
            "SS": "https://i.ibb.co/3mNqHvqH/2fXUIrn.png"
        };

        function getUrl(s) {
            if (s.startsWith("http")) {
                if (s.endsWith(".jpg") || s.endsWith(".gif") || s.endsWith(".webp")) {
                    return s;
                }
                return s + ".png";
            }
            if (s.endsWith(".jpg") || s.endsWith(".gif") || s.endsWith(".webp")) {
                return "https://i.ibb.co/" + s;
            }
            return "https://i.ibb.co/" + s + ".png";
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusDiv');
            const statusText = document.getElementById('statusText');

            statusDiv.className = `processing-status status-${type}`;
            statusDiv.style.display = 'block';
            statusText.textContent = message;
        }

        function showValidationError(errorMessage, details = '') {
            const statusDiv = document.getElementById('statusDiv');
            const statusText = document.getElementById('statusText');

            statusDiv.className = 'processing-status status-error';
            statusDiv.style.display = 'block';
            
            if (details) {
                statusText.innerHTML = `<strong>❌ Validation Error:</strong><br>${errorMessage}<br><br><strong>Details:</strong><br>${details}`;
            } else {
                statusText.innerHTML = `<strong>❌ Validation Error:</strong><br>${errorMessage}`;
            }
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function parseCharacterCode(codeText) {
            const characters = [];

            // Validate input
            if (!codeText || codeText.trim() === '') {
                showValidationError(
                    'Empty input',
                    'Please paste character code to process'
                );
                return null;
            }

            // Split by 'new charInfo' and process each entry
            const entries = codeText.split('new charInfo').filter(entry => entry.trim());

            if (entries.length === 0) {
                showValidationError(
                    'No valid character entries found',
                    'No "new charInfo" entries found in the provided code. Please check your input format.'
                );
                return null;
            }

            for (let entryIndex = 0; entryIndex < entries.length; entryIndex++) {
                const entry = entries[entryIndex];
                
                try {
                    // Extract parameters using regex to handle various quote types and formats
                    const params = entry.match(/\(([^)]+)\)/);
                    if (!params) {
                        showValidationError(
                            'Invalid character entry format',
                            `Entry ${entryIndex + 1}: Missing parentheses or malformed syntax\n\nEntry: ${entry.trim()}`
                        );
                        return null; // Stop processing
                    }

                    const paramString = params[1];

                    // Validate bracket balance
                    let bracketCount = 0;
                    let quoteCount = 0;
                    let inQuotes = false;
                    let quoteChar = '';

                    for (let i = 0; i < paramString.length; i++) {
                        const char = paramString[i];
                        
                        if ((char === '"' || char === "'") && !inQuotes) {
                            inQuotes = true;
                            quoteChar = char;
                            quoteCount++;
                        } else if (char === quoteChar && inQuotes) {
                            inQuotes = false;
                            quoteCount++;
                        } else if (char === '[' && !inQuotes) {
                            bracketCount++;
                        } else if (char === ']' && !inQuotes) {
                            bracketCount--;
                            if (bracketCount < 0) {
                                showValidationError(
                                    'Unmatched brackets',
                                    `Entry ${entryIndex + 1}: Unmatched closing bracket ']'\n\nEntry: ${entry.trim()}`
                                );
                                return null;
                            }
                        }
                    }

                    // Check for unclosed brackets
                    if (bracketCount !== 0) {
                        showValidationError(
                            'Unmatched brackets',
                            `Entry ${entryIndex + 1}: Unmatched brackets detected (count: ${bracketCount})\n\nEntry: ${entry.trim()}`
                        );
                        return null;
                    }

                    // Split by commas but respect quotes and brackets
                    const parts = [];
                    let current = '';
                    inQuotes = false;
                    quoteChar = '';
                    bracketCount = 0;

                    for (let i = 0; i < paramString.length; i++) {
                        const char = paramString[i];

                        if ((char === '"' || char === "'") && !inQuotes) {
                            inQuotes = true;
                            quoteChar = char;
                            current += char;
                        } else if (char === quoteChar && inQuotes) {
                            inQuotes = false;
                            current += char;
                        } else if (char === '[' && !inQuotes) {
                            bracketCount++;
                            current += char;
                        } else if (char === ']' && !inQuotes) {
                            bracketCount--;
                            current += char;
                        } else if (char === ',' && !inQuotes && bracketCount === 0) {
                            parts.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }

                    if (current.trim()) {
                        parts.push(current.trim());
                    }

                    // Validate parameter count
                    if (parts.length !== 7) {
                        showValidationError(
                            'Incorrect number of parameters',
                            `Entry ${entryIndex + 1}: Expected 7 parameters, found ${parts.length}\n\nEntry: ${entry.trim()}\n\nExpected format: new charInfo('Name', ['Alias'], anime[Number], 'Gender', 'ImageURL', ID, 'Rarity')`
                        );
                        return null; // Stop processing
                    }

                    // Extract and validate values
                    let name = parts[0].trim();
                    let aliases = parts[1];
                    let animeInfo = parts[2].trim();
                    let gender = parts[3].replace(/['"]/g, '').trim();
                    let image = parts[4].replace(/['"]/g, '').trim();
                    let id = parts[5].trim();
                    let rarity = parts[6].replace(/['"]/g, '').trim();

                    // Validate name
                    if (!name || name.length === 0) {
                        showValidationError(
                            'Invalid character name',
                            `Entry ${entryIndex + 1}: Character name cannot be empty\n\nEntry: ${entry.trim()}`
                        );
                        return null;
                    }

                    // Clean name by removing outer quotes but preserving content
                    name = name.replace(/^['"]|['"]$/g, '');
                    if (!name || name.length === 0) {
                        showValidationError(
                            'Invalid character name',
                            `Entry ${entryIndex + 1}: Character name cannot be empty after removing quotes\n\nEntry: ${entry.trim()}`
                        );
                        return null;
                    }

                    // Parse and validate aliases
                    let parsedAliases = [];
                    try {
                        // Remove outer brackets and split by comma
                        const aliasString = aliases.replace(/^\[|\]$/g, '');
                        if (aliasString.trim()) {
                            const aliasParts = aliasString.split(',').map(alias => {
                                // Remove outer quotes but preserve content
                                let cleanAlias = alias.trim().replace(/^['"]|['"]$/g, '');
                                return cleanAlias;
                            }).filter(alias => alias.length > 0);
                            parsedAliases = aliasParts;
                        }
                    } catch (error) {
                        showValidationError(
                            'Invalid alias format',
                            `Entry ${entryIndex + 1}: Unable to parse aliases\n\nEntry: ${entry.trim()}\n\nError: ${error.message}`
                        );
                        return null;
                    }

                    // Validate gender
                    if (!gender || !['M', 'F'].includes(gender.toUpperCase())) {
                        showValidationError(
                            'Invalid gender value',
                            `Entry ${entryIndex + 1}: Gender must be 'M' or 'F', found '${gender}'\n\nEntry: ${entry.trim()}`
                        );
                        return null;
                    }
                    gender = gender.toUpperCase();

                    // Validate rarity
                    const validRarities = ['D', 'C', 'B', 'A', 'S', 'SS'];
                    if (!rarity || !validRarities.includes(rarity.toUpperCase())) {
                        showValidationError(
                            'Invalid rarity value',
                            `Entry ${entryIndex + 1}: Rarity must be one of: D, C, B, A, S, SS. Found '${rarity}'\n\nEntry: ${entry.trim()}`
                        );
                        return null;
                    }
                    rarity = rarity.toUpperCase();

                    // Validate ID (must be a number)
                    let parsedId = parseInt(id);
                    if (isNaN(parsedId) || parsedId < 0) {
                        showValidationError(
                            'Invalid character ID',
                            `Entry ${entryIndex + 1}: Character ID must be a valid number, found '${id}'\n\nEntry: ${entry.trim()}`
                        );
                        return null;
                    }

                    // Validate animeInfo format
                    if (!animeInfo.match(/^anime\[\d+\]$/)) {
                                            showValidationError(
                        'Invalid animeInfo format',
                        `Entry ${entryIndex + 1}: animeInfo must be in format 'anime[Number]', found '${animeInfo}'\n\nEntry: ${entry.trim()}\n\nCorrect format: anime[0], anime[1], etc.`
                    );
                        return null;
                    }

                    // Validate image URL
                    if (!image || image.trim() === '') {
                        showValidationError(
                            'Missing image URL',
                            `Entry ${entryIndex + 1}: Image URL cannot be empty\n\nEntry: ${entry.trim()}`
                        );
                        return null;
                    }

                    // Handle apostrophes in name and aliases (auto-convert to double quotes)
                    const formattedName = formatCharacterName(name);
                    const formattedAliases = formatAliasesArray(parsedAliases);

                    // Create properly formatted original entry
                    const originalEntry = `new charInfo(${formattedName}, ${formattedAliases}, ${animeInfo}, "${gender}", "${image}", ${parsedId}, "${rarity}"),`;

                    characters.push({
                        name: name,
                        aliases: parsedAliases,
                        animeInfo: animeInfo,
                        gender: gender,
                        image: image,
                        id: parsedId.toString(),
                        rarity: rarity,
                        originalEntry: originalEntry
                    });

                    console.log(`✅ Successfully parsed character: ${name} (${rarity})`);

                } catch (error) {
                    showValidationError(
                        'Error parsing character entry',
                        `Entry ${entryIndex + 1}: ${error.message}\n\nEntry: ${entry.trim()}`
                    );
                    return null;
                }
            }

            return characters;
        }

        async function processCharacters() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const charCode = document.getElementById('charCode').value.trim();

            if (!apiKey) {
                showStatus('Please enter your ImgBB API key', 'error');
                return;
            }

            // Test API key before processing
            try {
                const isValid = await testApiKey(apiKey);
                if (!isValid) {
                    showStatus('❌ Invalid API Key! Please check your ImgBB API key in the API Settings.', 'error');
                    return;
                }
            } catch (error) {
                showStatus(`❌ API Key test failed: ${error.message}`, 'error');
                return;
            }

            // Combine characters from both sources
            let allCharacters = [];

            // Parse characters from pasted code
            if (charCode) {
                const parsedCharacters = parseCharacterCode(charCode);
                if (parsedCharacters === null) {
                    // If parseCharacterCode returned null, it means there was a validation error.
                    // No need to proceed with processing.
                    return;
                }
                allCharacters = allCharacters.concat(parsedCharacters);
            }

            // Add manually entered characters
            if (manualCharacters.length > 0) {
                const manualCharObjects = manualCharacters.map(char => {
                    const aliasesString = formatAliasesArray(char.aliases);
                    return {
                        name: char.name,
                        aliases: aliasesString,
                        animeInfo: char.animeInfoNum,
                        gender: char.gender,
                        image: char.image,
                        id: char.id.toString(),
                        rarity: char.rarity,
                        originalEntry: `new charInfo("${char.name}", ${aliasesString}, anime[${char.animeInfoNum}], "${char.gender}", "${char.image}", ${char.id}, "${char.rarity}"),`
                    };
                });
                allCharacters = allCharacters.concat(manualCharObjects);
            }

            if (allCharacters.length === 0) {
                showStatus('No characters found. Please paste character code or add characters manually', 'error');
                return;
            }

            showStatus('Processing characters...', 'processing');
            updateProgress(0);

            const results = [];

            for (let i = 0; i < allCharacters.length; i++) {
                const char = allCharacters[i];

                try {
                    showStatus(`Processing ${char.name}... (${i + 1}/${allCharacters.length})`, 'processing');
                    updateProgress((i / allCharacters.length) * 90);

                    const processedUrl = await processCharacter(char, apiKey);

                    if (processedUrl) {
                        console.log(`✅ Processed ${char.name}: ${processedUrl}`);
                        // Replace the image URL in the original entry
                        const updatedEntry = char.originalEntry.replace(
                            new RegExp(`['"]${char.image.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"]`),
                            `'${processedUrl}'`
                        );
                        results.push('    ' + updatedEntry);
                    } else {
                        console.log(`❌ Failed to process ${char.name}`);
                        results.push(`    // ERROR processing ${char.name}: Image processing failed`);
                        results.push('    ' + char.originalEntry);
                    }
                } catch (error) {
                    console.error(`❌ Error processing character ${char.name}:`, error);
                    results.push(`    // ERROR processing ${char.name}: ${error.message}`);
                    results.push('    ' + char.originalEntry);
                }
            }

            updateProgress(100);
            showStatus(`Successfully processed ${allCharacters.length} characters!`, 'success');

            const outputCode = document.getElementById('outputCode');
            outputCode.textContent = results.join('\n');
        }

        async function processCharacter(character, apiKey) {
            try {
                console.log(`🔄 Processing character: ${character.name} (${character.rarity})`);

                // Get the image URL
                const imageUrl = getUrl(character.image);
                console.log(`📸 Character image URL: ${imageUrl}`);

                // Validate image URL format
                if (!imageUrl.startsWith('http')) {
                    throw new Error(`Invalid image URL format: ${imageUrl}`);
                }

                // Create canvas to process the image
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 225;
                canvas.height = 350;

                // Try to load the character image
                let charImg;
                try {
                    charImg = await loadImageWithMultipleProxies(imageUrl);
                } catch (error) {
                    console.error(`❌ Failed to load character image for ${character.name}:`, error);
                    throw new Error(`Failed to load character image: ${error.message}`);
                }

                // Draw character image
                ctx.drawImage(charImg, 0, 0, 225, 350);

                // Load and apply border
                //const borderUrl = borders[character.rarity];
                //console.log(`🖼️ Border URL: ${borderUrl}`);

                let borderImg;
                try {
                    borderImg = await loadBorderWithFallback(character.rarity);
                    ctx.drawImage(borderImg, 0, 0, 225, 350);
                    console.log(`✅ Applied ${character.rarity} border to ${character.name}`);
                } catch (error) {
                    console.warn(`⚠️ Failed to load border for ${character.name}, continuing without border:`, error);
                    // Continue without border instead of failing completely
                }

                // Convert canvas to blob
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });

                if (!blob) {
                    throw new Error('Failed to create image blob');
                }

                // Validate blob size
                if (blob.size === 0) {
                    throw new Error('Generated image blob is empty');
                }

                // Upload to imgbb with timeout
                console.log(`☁️ Uploading ${character.name} to ImgBB...`);
                const formData = new FormData();
                formData.append('key', apiKey);
                formData.append('image', blob);
                formData.append('name', `${character.name.replace(/\s+/g, '_')}_processed`);

                const response = await Promise.race([
                    fetch('https://api.imgbb.com/1/upload', {
                        method: 'POST',
                        body: formData
                    }),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('ImgBB upload timeout')), 30000)
                    )
                ]);

                if (!response.ok) {
                    if (response.status === 400) {
                        throw new Error('Invalid API key or malformed request - please check your API key');
                    } else if (response.status === 403) {
                        throw new Error('API key is invalid or expired - please update your API key');
                    } else if (response.status === 429) {
                        throw new Error('Rate limit exceeded - please wait and try again');
                    } else {
                        throw new Error(`ImgBB upload failed with status: ${response.status} ${response.statusText}`);
                    }
                }

                const result = await response.json();

                if (result.success) {
                    console.log(`✅ Successfully uploaded ${character.name}: ${result.data.url}`);
                    return result.data.url;
                } else {
                    console.error(`❌ ImgBB upload failed for ${character.name}:`, result);
                    throw new Error(`ImgBB upload failed: ${result.error?.message || 'Unknown error'}`);
                }

            } catch (error) {
                console.error(`❌ Error processing ${character.name}:`, error);
                return null;
            }
        }

        // Multiple CORS proxy options for better reliability
        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/',
            'https://api.codetabs.com/v1/proxy?quest='
        ];

        // Enhanced image loading with multiple proxy fallbacks
        async function loadImageWithMultipleProxies(url, maxRetries = 2) {
            // First try direct access (works for CORS-enabled domains like imgur)
            try {
                console.log(`🔄 Trying direct access: ${url}`);
                return await loadImageDirect(url);
            } catch (error) {
                console.warn(`⚠️ Direct access failed for ${url}: ${error.message}`);
            }

            // Try each proxy
            for (let proxyIndex = 0; proxyIndex < CORS_PROXIES.length; proxyIndex++) {
                const proxy = CORS_PROXIES[proxyIndex];

                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        const proxyUrl = proxy + encodeURIComponent(url);
                        console.log(`🔄 Trying proxy ${proxyIndex + 1}/${CORS_PROXIES.length}, attempt ${attempt}/${maxRetries}: ${proxy}`);

                        return await loadImageDirect(proxyUrl);
                    } catch (error) {
                        console.warn(`⚠️ Proxy ${proxy} attempt ${attempt} failed: ${error.message}`);

                        if (attempt < maxRetries) {
                            const delay = 1000 * attempt; // Linear backoff
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }
            }

            throw new Error(`All proxy attempts failed for: ${url}`);
        }

        // Direct image loading function
        function loadImageDirect(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';

                const timeoutId = setTimeout(() => {
                    reject(new Error(`Timeout loading image: ${url}`));
                }, 10000); // 10 second timeout per attempt

                img.onload = function() {
                    clearTimeout(timeoutId);
                    try {
                        // Test canvas compatibility
                        const testCanvas = document.createElement("canvas");
                        const testCtx = testCanvas.getContext("2d");
                        testCanvas.width = 1;
                        testCanvas.height = 1;
                        testCtx.drawImage(img, 0, 0, 1, 1);
                        testCtx.getImageData(0, 0, 1, 1);

                        console.log(`✅ Successfully loaded: ${url}`);
                        resolve(img);
                    } catch (e) {
                        reject(new Error(`Canvas access denied: ${url}`));
                    }
                };

                img.onerror = function() {
                    clearTimeout(timeoutId);
                    reject(new Error(`Failed to load: ${url}`));
                };

                img.src = url;
            });
        }

        // Enhanced border loading with fallbacks
        async function loadBorderWithFallback(rarity) {
            const primaryUrl = borders[rarity];
            const fallbackUrl = borderFallbacks[rarity];

            try {
                console.log(`🖼️ Loading ${rarity} border from primary source...`);
                return await loadImageWithMultipleProxies(primaryUrl);
            } catch (error) {
                console.warn(`⚠️ Primary border failed, trying fallback: ${error.message}`);

                if (fallbackUrl && fallbackUrl !== "https://i.ibb.co/YOUR_" + rarity + "_BORDER_ID.png") {
                    try {
                        return await loadImageWithMultipleProxies(fallbackUrl);
                    } catch (fallbackError) {
                        console.error(`❌ Fallback border also failed: ${fallbackError.message}`);
                    }
                }

                throw new Error(`All border sources failed for rarity: ${rarity}`);
            }
        }

        // Tab management
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            if (tabName === 'manual') {
                document.querySelector('.tab-button:first-child').classList.add('active');
                document.getElementById('manual-tab').classList.add('active');
            } else if (tabName === 'code') {
                document.querySelector('.tab-button:last-child').classList.add('active');
                document.getElementById('code-tab').classList.add('active');
            }
        }

        // Manual character management
        let manualCharacters = [];
        let currentCharacterId; // Starting ID
        let currentAnimeInfoNum; // Current anime info number

        async function addManualCharacter() {
            const name = document.getElementById('charName').value.trim();
            const aliasInput = document.getElementById('charAlias').value.trim();
            const gender = document.getElementById('charGender').value;
            const image = document.getElementById('charImage').value.trim();
            const rarity = document.getElementById('charRarity').value;

            // Use preserved values
            const animeInfoNum = currentAnimeInfoNum;
            const id = currentCharacterId;

            // Process aliases - split by comma and trim each alias
            const aliases = aliasInput ? aliasInput.split(',').map(alias => alias.trim()).filter(alias => alias.length > 0) : [];

            // Validation
            if (!document.getElementById('apiKey').value.trim()) {
                alert('No API key found');
                return;
            }
            if (!name) {
                alert('Please enter a character name');
                return;
            }
            if (!gender) {
                alert('Please select a gender');
                return;
            }
            if (!image) {
                alert('Please enter an image URL or ID');
                return;
            }
            if (!rarity) {
                alert('Please select a rarity');
                return;
            }
            if (!animeInfoNum) {
                alert('Please enter an anime ID');
                return;
            }
            if (!id) {
                alert('Please enter a character ID');
                return;
            }

            // Create character object
            const character = {
                name: name,
                aliases: aliases,
                animeInfoNum: parseInt(animeInfoNum),
                gender: gender,
                image: image,
                id: parseInt(id),
                rarity: rarity,
                timestamp: Date.now(),
                processed: false,
                processedUrl: null,
                processingError: null
            };

            // Add to array
            manualCharacters.push(character);

            // Update display
            updateManualCharactersList();

            // Clear form
            clearManualForm();

            // Process the character with borders immediately
            await processSingleManualCharacter(character);

            // Update output code
            updateOutputWithManualCharacters();
        }

        function removeManualCharacter(timestamp) {
            manualCharacters = manualCharacters.filter(char => char.timestamp !== timestamp);
            updateManualCharactersList();
            updateOutputWithManualCharacters();
        }

        function updateManualCharactersList() {
            const list = document.getElementById('manualCharactersList');
            
            if (manualCharacters.length === 0) {
                list.innerHTML = '<p style="color: #666; text-align: center; font-style: italic;">No characters added yet</p>';
                return;
            }

            list.innerHTML = manualCharacters.map(char => {
                let statusHtml = '';
                let detailsHtml = '';
                
                if (char.processed && char.processedUrl) {
                    statusHtml = '<span style="color: #28a745; font-size: 0.8em;"> ✅ Processed</span>';
                    detailsHtml = `<br><span style="color: #28a745; font-size: 0.9em;">✅ Processed with borders</span>`;
                } else if (char.processingError) {
                    statusHtml = '<span style="color: #dc3545; font-size: 0.8em;"> ❌ Failed</span>';
                    detailsHtml = `<br><span style="color: #dc3545; font-size: 0.9em;">❌ ${char.processingError}</span>`;
                } else {
                    statusHtml = '<span style="color: #ffc107; font-size: 0.8em;"> ⏳ Processing...</span>';
                }
                
                return `
                    <div class="character-item">
                        <div class="character-info">
                            <div class="character-name">
                                ${char.name}${statusHtml}
                            </div>
                            <div class="character-details">
                                ${char.aliases && char.aliases.length > 0 ? `Aliases: ${char.aliases.join(', ')} | ` : ''}
                                Anime Info: ${char.animeInfoNum} | 
                                Gender: ${char.gender} | 
                                ID: ${char.id} | 
                                Rarity: ${char.rarity}${detailsHtml}
                            </div>
                        </div>
                        <button class="remove-char-btn" onclick="removeManualCharacter(${char.timestamp})">Remove</button>
                    </div>
                `;
            }).join('');
        }

        function clearManualForm() {
            document.getElementById('charName').value = '';
            document.getElementById('charAlias').value = '';
            document.getElementById('charGender').value = '';
            document.getElementById('charImage').value = '';
            document.getElementById('charRarity').value = '';
            
            // Preserve anime info number and auto-increment character ID
            document.getElementById('animeInfoNum').value = currentAnimeInfoNum;
            currentCharacterId++;
            document.getElementById('charId').value = currentCharacterId;
        }

        function clearAllManualCharacters() {
            if (manualCharacters.length === 0) {
                alert('No characters to clear');
                return;
            }
            
            if (confirm(`Are you sure you want to remove all ${manualCharacters.length} manually added characters?`)) {
                manualCharacters = [];
                updateManualCharactersList();
                updateOutputWithManualCharacters();
            }
        }

        async function processSingleManualCharacter(character) {
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (!apiKey) {
                console.warn('No API key found');
                character.processed = false;
                character.processedUrl = null;
                character.processingError = 'No API key found';
                updateManualCharactersList();
                return;
            }

            // Test API key before processing
            try {
                const isValid = await testApiKey(apiKey);
                if (!isValid) {
                    character.processed = false;
                    character.processedUrl = null;
                    character.processingError = 'Invalid API key - please check API Settings';
                    updateManualCharactersList();
                    return;
                }
            } catch (error) {
                character.processed = false;
                character.processedUrl = null;
                character.processingError = `API Key test failed: ${error.message}`;
                updateManualCharactersList();
                return;
            }

            try {
                console.log(`🔄 Processing manual character: ${character.name} (${character.rarity})`);
                
                // Create character object for processing
                const aliasesString = formatAliasesArray(character.aliases);
                const formattedName = formatCharacterName(character.name);
                const charForProcessing = {
                    name: character.name,
                    aliases: aliasesString,
                    animeInfo: 'anime[' + character.animeInfoNum.toString() + ']',
                    gender: character.gender,
                    image: character.image,
                    id: character.id.toString(),
                    rarity: character.rarity,
                    originalEntry: `new charInfo(${formattedName}, ${aliasesString}, anime[' + ${character.animeInfoNum.toString()} + '], "${character.gender}", "${character.image}", ${character.id}, "${character.rarity}"),`
                };

                const processedUrl = await processCharacter(charForProcessing, apiKey);
                
                if (processedUrl) {
                    // Update the character with processed URL
                    character.processed = true;
                    character.processedUrl = processedUrl;
                    character.processingError = null;
                    console.log(`✅ Successfully processed ${character.name}: ${processedUrl}`);
                } else {
                    // Mark as failed
                    character.processed = false;
                    character.processedUrl = null;
                    character.processingError = 'Image processing failed';
                    console.log(`❌ Failed to process ${character.name}`);
                }
                
                // Update the display to show processing status
                updateManualCharactersList();
                
            } catch (error) {
                console.error(`❌ Error processing manual character ${character.name}:`, error);
                // Mark as failed with error message
                character.processed = false;
                character.processedUrl = null;
                character.processingError = error.message || 'Processing error occurred';
                updateManualCharactersList();
            }
        }

        function copyManualCharacters() {
            if (manualCharacters.length === 0) {
                alert('No characters to copy');
                return;
            }

            const characterCode = manualCharacters.map(char => {
                const aliasArray = formatAliasesArray(char.aliases);
                const formattedName = formatCharacterName(char.name);
                const imageUrl = char.processed && char.processedUrl ? char.processedUrl : char.image;
                return `    new charInfo(${formattedName}, ${aliasArray}, anime[${char.animeInfoNum}], "${char.gender}", "${imageUrl}", ${char.id}, "${char.rarity}"),`;
            }).join('\n');

            navigator.clipboard.writeText(characterCode).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '✅ Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }).catch(() => {
                const textArea = document.createElement('textarea');
                textArea.value = characterCode;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '✅ Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            });
        }

        // Helper function to format aliases with double quotes
        function formatAliasesArray(aliases) {
            if (!aliases || aliases.length === 0) {
                return '[]';
            }
            
            // Process each alias to handle quotes properly
            const processedAliases = aliases.map(alias => {
                // Remove any existing quotes first
                let cleanAlias = alias.replace(/^['"]|['"]$/g, '');
                
                // Convert any double quotes in content to apostrophes
                cleanAlias = cleanAlias.replace(/"/g, "'");
                
                // Always use double quotes for the outer string
                return `"${cleanAlias}"`;
            });
            
            return `[${processedAliases.join(', ')}]`;
        }

        // Helper function to format character names with double quotes
        function formatCharacterName(name) {
            if (!name) return '""';
            
            // Remove any existing quotes first
            let cleanName = name.replace(/^['"]|['"]$/g, '');
            
            // Convert any double quotes in content to apostrophes
            cleanName = cleanName.replace(/"/g, "'");
            
            // Always use double quotes for the outer string
            return `"${cleanName}"`;
        }

        // Initialize form with default values
        function initializeForm() {
            document.getElementById('animeInfoNum').value = currentAnimeInfoNum;
            document.getElementById('charId').value = currentCharacterId;
            
            // Add event listeners for field changes
            document.getElementById('animeInfoNum').addEventListener('change', function() {
                currentAnimeInfoNum = parseInt(this.value);
            });
            
            document.getElementById('charId').addEventListener('change', function() {
                currentCharacterId = parseInt(this.value);
            });
        }

        function updateOutputWithManualCharacters() {
            const outputCode = document.getElementById('outputCode');
            
            if (manualCharacters.length === 0) {
                const defaultText = `// Your processed character code will appear here...
// Paste your existing character code and click "Apply Borders & Upload"

Expected input format:
new charInfo("Name", ["Alias"], anime[0], "M", "image_url", 1, "S"),

Output format (with processed images):
new charInfo("Name", ["Alias"], anime[0], "M", "processed_image_url", 1, "S"),`;
                
                outputCode.textContent = defaultText;
                return;
            }

            const characterCode = manualCharacters.map(char => {
                const aliasArray = formatAliasesArray(char.aliases);
                const formattedName = formatCharacterName(char.name);
                const imageUrl = char.processed && char.processedUrl ? char.processedUrl : char.image;
                return `    new charInfo(${formattedName}, ${aliasArray}, anime[${char.animeInfoNum}], "${char.gender}", "${imageUrl}", ${char.id}, "${char.rarity}"),`;
            }).join('\n');

            outputCode.textContent = characterCode;
        }

        function copyOutput() {
            const outputCode = document.getElementById('outputCode');
            navigator.clipboard.writeText(outputCode.textContent).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '✅ Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }).catch(() => {
                const textArea = document.createElement('textarea');
                textArea.value = outputCode.textContent;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '✅ Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            });
        }

        // Initialize the form when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeForm();
        });

        // Handle image file upload
        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file');
                return;
            }

            // Validate file size (32MB limit)
            if (file.size > 32 * 1024 * 1024) {
                alert('File size must be less than 32MB');
                return;
            }

            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                alert('Please enter your ImgBB API key first');
                return;
            }

            // Test API key before uploading
            try {
                const isValid = await testApiKey(apiKey);
                if (!isValid) {
                    alert('❌ Invalid API Key!\n\nPlease check your ImgBB API key in the API Settings.\n\nYou can get a free API key from: https://api.imgbb.com/');
                    return;
                }
            } catch (error) {
                alert('❌ API Key test failed!\n\nError: ' + error.message + '\n\nPlease check your API key in the API Settings.');
                return;
            }

            try {
                // Show loading overlay
                const loadingOverlay = document.getElementById('loadingOverlay');
                const loadingText = document.getElementById('loadingText');
                const loadingSubtext = document.getElementById('loadingSubtext');
                
                loadingText.textContent = 'Uploading Image...';
                loadingSubtext.textContent = 'Please wait while we upload your image to ImgBB';
                loadingOverlay.style.display = 'flex';

                // Create FormData for upload
                const formData = new FormData();
                formData.append('key', apiKey);
                formData.append('image', file);
                formData.append('name', file.name.replace(/\.[^/.]+$/, ''));

                // Upload to ImgBB
                const response = await fetch('https://api.imgbb.com/1/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    // Update the image URL field with the uploaded URL
                    document.getElementById('charImage').value = result.data.url;
                    showStatus('Image uploaded successfully!', 'success');
                    console.log(`✅ Image upload successful: ${result.data.url}`);
                } else {
                    showStatus(`Upload failed: ${result.error?.message || 'Unknown error'}`, 'error');
                    console.error('❌ Image upload failed:', result);
                }
            } catch (error) {
                let errorMessage = error.message;
                
                // Handle specific error types
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMessage = 'Network error - please check your internet connection';
                } else if (error.message.includes('timeout')) {
                    errorMessage = 'Upload timed out - please try again';
                } else if (error.message.includes('status')) {
                    errorMessage = `Server error: ${error.message}`;
                }
                
                showStatus(`Upload failed: ${errorMessage}`, 'error');
                console.error('❌ Image upload error:', error);
            } finally {
                // Hide loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';
            }

            // Clear the file input
            event.target.value = '';
        }

        // API Key Modal Functions
        function openApiKeyModal() {
            console.log('🔧 Opening API Key Modal...');
            
            const modal = document.getElementById('apiKeyModal');
            const modalApiKey = document.getElementById('modalApiKey');
            const currentApiKey = document.getElementById('apiKey');
            
            console.log('Modal element:', modal);
            console.log('Modal API Key element:', modalApiKey);
            console.log('Current API Key element:', currentApiKey);
            
            if (!modal) {
                console.error('❌ Modal not found!');
                alert('Modal not found - please refresh the page');
                return;
            }
            
            if (!modalApiKey) {
                console.error('❌ Modal API Key input not found!');
                alert('Modal input not found - please refresh the page');
                return;
            }
            
            if (!currentApiKey) {
                console.error('❌ Current API Key input not found!');
                alert('API Key input not found - please refresh the page');
                return;
            }
            
            // Load current API key into modal
            modalApiKey.value = currentApiKey.value;
            
            // Show modal
            modal.style.display = 'flex';
            console.log('✅ Modal should now be visible');
            
            // Focus on the input
            modalApiKey.focus();
        }

        function closeApiKeyModal() {
            const modal = document.getElementById('apiKeyModal');
            modal.style.display = 'none';
        }

        function toggleModalApiKeyVisibility() {
            const apiKeyInput = document.getElementById('modalApiKey');
            const toggleButton = event.target;
            const statusText = document.getElementById('modalApiKeyStatus');

            if (apiKeyInput.type === 'password') {
                apiKeyInput.type = 'text';
                toggleButton.textContent = '🙈 Hide';
                statusText.textContent = 'API Key is visible';
                statusText.className = 'api-key-status valid';
            } else {
                apiKeyInput.type = 'password';
                toggleButton.textContent = '👁️ Show';
                statusText.textContent = 'API Key is hidden';
                statusText.className = 'api-key-status invalid';
            }
        }

        function saveApiKey() {
            const modalApiKey = document.getElementById('modalApiKey');
            const mainApiKey = document.getElementById('apiKey');
            const newApiKey = modalApiKey.value.trim();
            
            if (!newApiKey) {
                alert('Please enter an API key');
                return;
            }
            
            // Show testing overlay
            showApiKeyTestingOverlay();
            
            // Test the API key before saving
            testApiKey(newApiKey).then(isValid => {
                hideApiKeyTestingOverlay();
                
                if (isValid) {
                    // Save to main API key field
                    mainApiKey.value = newApiKey;
                    
                    // Show success message
                    showStatus('API Key saved successfully!', 'success');
                    
                    // Close modal
                    closeApiKeyModal();
                } else {
                    alert('❌ Invalid API Key!\n\nPlease check your ImgBB API key and try again.\n\nYou can get a free API key from: https://api.imgbb.com/');
                }
            }).catch(error => {
                hideApiKeyTestingOverlay();
                console.error('API Key test failed:', error);
                alert('❌ API Key test failed!\n\nError: ' + error.message + '\n\nPlease check your internet connection and try again.');
            });
        }

        function showApiKeyTestingOverlay() {
            const apiTestingOverlay = document.getElementById('apiTestingOverlay');
            const apiTestingText = document.getElementById('apiTestingText');
            const apiTestingSubtext = document.getElementById('apiTestingSubtext');
            
            apiTestingText.textContent = 'Testing API Key...';
            apiTestingSubtext.textContent = 'Please wait while we validate your ImgBB API key';
            apiTestingOverlay.style.display = 'flex';
        }

        function hideApiKeyTestingOverlay() {
            const apiTestingOverlay = document.getElementById('apiTestingOverlay');
            apiTestingOverlay.style.display = 'none';
        }

        // Test API key validity
        async function testApiKey(apiKey) {
            try {
                // Update loading text to show current step
                const apiTestingText = document.getElementById('apiTestingText');
                const apiTestingSubtext = document.getElementById('apiTestingSubtext');
                
                apiTestingText.textContent = 'Testing API Key...';
                apiTestingSubtext.textContent = 'Step 1/3: Creating test image...';
                
                // Create a small test image (1x1 pixel)
                const canvas = document.createElement('canvas');
                canvas.width = 1;
                canvas.height = 1;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 1, 1);
                
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });

                apiTestingSubtext.textContent = 'Step 2/3: Preparing upload request...';
                
                const formData = new FormData();
                formData.append('key', apiKey);
                formData.append('image', blob);
                formData.append('name', 'test_upload');

                apiTestingSubtext.textContent = 'Step 3/3: Sending test upload to ImgBB...';
                
                const response = await fetch('https://api.imgbb.com/1/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    if (response.status === 400) {
                        throw new Error('Invalid API key or malformed request');
                    } else if (response.status === 403) {
                        throw new Error('API key is invalid or expired');
                    } else if (response.status === 429) {
                        throw new Error('Rate limit exceeded - please wait and try again');
                    } else {
                        throw new Error(`Server error: ${response.status} ${response.statusText}`);
                    }
                }

                const result = await response.json();
                
                if (result.success) {
                    console.log('✅ API Key test successful');
                    return true;
                } else {
                    console.error('❌ API Key test failed:', result);
                    throw new Error(result.error?.message || 'Unknown API error');
                }
                
            } catch (error) {
                console.error('❌ API Key test error:', error);
                throw error;
            }
        }

        // Close modal when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('apiKeyModal');
            modal.addEventListener('click', function(event) {
                if (event.target === modal) {
                    closeApiKeyModal();
                }
            });
        });
    </script>
</body>
</html>